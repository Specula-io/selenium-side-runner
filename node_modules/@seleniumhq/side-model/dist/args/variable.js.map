{"version":3,"sources":["../../src/args/variable.ts"],"names":["firstVariableCharacterTokenRegex","anyVariableCharacterTokenRegex","integerCharacterTokenRegex","Argument","name","description","identify","value","validate","parseVariable","length","position","parseVariableName","validTerminatingCharacters","lastPosition","isInArrayMode","SyntaxError","token","test","parseInteger","throwUnexpectedToken","throwMissingToken","firstTokenChecked","includes","arrayIndex"],"mappings":"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","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport Argument from './argument'\n\n// TODO: replace all this with esprima\nconst firstVariableCharacterTokenRegex = /[a-z_]/i\nconst anyVariableCharacterTokenRegex = /[a-z0-9_]/i\nconst integerCharacterTokenRegex = /[0-9]/\n\nexport default new Argument({\n  name: 'Variable',\n  description: `The name of a variable (without brackets). Used to either store \n    an expression's result in or reference for a check (e.g., with 'assert' or \n    'verify').`,\n  identify: (value: string) => typeof value === 'string',\n  validate: (value: string) => {\n    return parseVariable(value) === value.length\n  },\n})\n\nfunction parseVariable(value: string) {\n  let position = parseVariableName({\n    value,\n    position: 0,\n    validTerminatingCharacters: ['.', '[', ']'],\n  })\n  let lastPosition = 0\n  let isInArrayMode = false\n  while (position < value.length) {\n    if (lastPosition === position) {\n      throw new SyntaxError(\n        `Unable to parse variable ${value} at position ${position} character ${value[position]}`\n      )\n    }\n    lastPosition = position\n    const token = value[position]\n    if (token === '.') {\n      position = parseVariableName({\n        value,\n        position: position + 1,\n        validTerminatingCharacters: ['.'],\n      })\n    } else if (token === '[') {\n      isInArrayMode = true\n      if (integerCharacterTokenRegex.test(value[position + 1])) {\n        position = parseInteger({\n          value,\n          position: position + 1,\n          validTerminatingCharacters: [']'],\n        })\n      } else {\n        position = parseVariableName({\n          value,\n          position: position + 1,\n          validTerminatingCharacters: ['.', ']'],\n        })\n      }\n    } else if (token === ']') {\n      if (isInArrayMode) {\n        isInArrayMode = false\n        position += 1\n      } else {\n        throwUnexpectedToken(token)\n      }\n    }\n  }\n\n  if (isInArrayMode) {\n    throwMissingToken(']')\n  }\n\n  return position\n}\n\nfunction parseVariableName({\n  value,\n  position,\n  validTerminatingCharacters,\n}: {\n  value: string\n  position: number\n  validTerminatingCharacters: string[]\n}) {\n  let firstTokenChecked = false\n  while (position < value.length) {\n    const token = value[position]\n\n    if (!firstTokenChecked) {\n      firstTokenChecked = true\n      if (!firstVariableCharacterTokenRegex.test(token)) {\n        throwUnexpectedToken(token)\n      }\n    } else if (validTerminatingCharacters.includes(token)) {\n      return position\n    } else if (!anyVariableCharacterTokenRegex.test(token)) {\n      throwUnexpectedToken(token)\n    }\n    position += 1\n  }\n  return position\n}\n\nfunction parseInteger({\n  value,\n  position,\n  validTerminatingCharacters,\n}: {\n  value: string\n  position: number\n  validTerminatingCharacters: string[]\n}) {\n  let arrayIndex = ''\n  while (position < value.length) {\n    const token = value[position]\n    if (arrayIndex === '0' && !validTerminatingCharacters.includes(token)) {\n      throwUnexpectedToken(token)\n    } else if (validTerminatingCharacters.includes(token)) {\n      if (!arrayIndex.length) {\n        throwUnexpectedToken(token)\n      }\n      return position\n    } else if (!integerCharacterTokenRegex.test(token)) {\n      throwUnexpectedToken(token)\n    }\n    arrayIndex += token\n    position += 1\n  }\n  return position\n}\n\nfunction throwUnexpectedToken(token: string) {\n  throw new SyntaxError(`Unexpected token ${token}`)\n}\n\nfunction throwMissingToken(token: string) {\n  throw new SyntaxError(`Missing token ${token}`)\n}\n"],"file":"variable.js"}